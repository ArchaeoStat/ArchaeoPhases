---
title: "Manual"
author: "A. Philippe, M.-A. Vibet"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
bibliography: bibliography.bib
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
vignette: >
  %\VignetteIndexEntry{Manual}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "./figures/",
  fig.align = "center",
  fig.width = 7,
  out.width = NULL
)
```

## Introduction

**chronos** provides a list of functions for the statistical analysis of archaeological dates and groups of dates. It is based on the post-processing of the Markov Chains whose stationary distribution is the posterior distribution of a series of dates. Such MCMC output can be simulated by different applications as for instance [ChronoModel](https://chronomodel.com/) [@lanos2020], [Oxcal](https://c14.arch.ox.ac.uk/oxcal.html) [@bronkramsey2009] or [BCal](https://bcal.shef.ac.uk/) [@buck1999]. The only requirement is to have a CSV file containing a sample from the posterior distribution.

```{r packages}
## Load packages
library(chronos)

library(coda) # MCMC diagnostic
```

## Import data

This vignette uses data available through the [**fasti**](https://packages.tesselle.org/fasti/) package which is available in a separate [repository](https://tesselle.r-universe.dev). **fasti** provides MCMC outputs from ChronoModel, OxCal and BCal.

```{r fasti, eval=FALSE}
## Install the latest version
install.packages("fasti", repos = "https://tesselle.r-universe.dev")
```

Let's use the data of Ksar Akil generated by ChronoModel [@bosch2015].

Two different files are generated by ChronoModel: `Chain_all_Events.csv` that contains the MCMC samples of each event created in the modeling, and `Chain_all_Phases.csv` that contains all the MCMC samples of the minimum and the maximum of each group of dates if at least one group is created.

```{r read-chronomodel-events}
chrono_path <- "chronomodel/ksarakil"

## Read events from ChronoModel
output_events <- system.file(chrono_path, "Chain_all_Events.csv", package = "fasti")
chrono_events <- read_chronomodel_events(output_events)

## Read phases from ChronoModel
output_phases <- system.file(chrono_path, "Chain_all_Phases.csv", package = "fasti")
chrono_phases <- read_chronomodel_phases(output_phases)
```

See `vignette("import")` for more details on how to import MCMC samples.

## Convergence of MCMC chains

For more details on the diagnostic of Markov chain, see @robert2010.

To assess the agreement between the posterior distributions and the numerical approximations, three Markov chains were run in parallel by ChronoModel. For each chain, 1 000 iterations were used during the Burn-in period, 20 batches of 500 iterations were used in the Adapt period, 100 000 iterations were drawn in the Acquire period by only 1 out of 10 were kept in order to break the correlation structure.

From the analysis of the history plot, all Markov chains reach their equilibrium before the Acquire period. The autocorrelations of the  three Markov chains are not significant, meaning the rate of subsample (1 over 10) is enough.

Now, using the package **chronos** and the package **coda**, we can verify whether the MCMC samples are correctly generated by the software.

```{r coda}
## Create an mcmc.list
coda_events <- as_coda(chrono_events, chains = 3)
```

```{r coda-raftery, echo=FALSE, eval=FALSE}
coda::raftery.diag(coda_events)
```

Indeed, the MCMC samples should have no autocorrelation and should have reached their equilibrium (that is the posterior density of the parameter under investigation).

```{r coda-autocor, fig.height=7}
coda::autocorr.plot(coda_events[[1]])
```

The autocorrelation plots show that each of these three chains are not significant. That means that we actually generated a non correlated sample, which was the aim the MCMC process.

We can also check whether the chains reached equilibrium. For example, let's consider the first date of the dataset.

```{r coda-plot, fig.height=5}
plot(coda_events[, 1, ], trace = TRUE, density = FALSE)
```

The plot shows that the three chains corresponding to the first date reached the same stationary process.

We can test the Gelman-Rubin criterion. The expected value to confirm that all of the Markov chains reached equilibrium is 1.

```{r coda-gelman}
coda::gelman.diag(coda_events)
```

The Gelman-Rubin criterion confirms that all of the Markov chains reached equilibrium.

We can also test the Geweke criterion. The expected value to confirm that all of the Markov chains reached equilibrium is strickly less than 1.

```{r coda-geweke, fig.height=5}
coda::geweke.diag(coda_events[, 1, ], frac1 = 0.1, frac2 = 0.5)
```

The Geweke criterion criterion confirms that all of the Markov chains reached equilibrium.

ChronoModel generated correct samples of the posterior distribution. Now gathering the three chains, a total of 30 000 iterations was collected in order to give estimations of the posterior distribution of each parameter.

## Analysis of a series of dates

```{r event-plot, fig.height=5}
plot(chrono_events)
```

### Tempo Plot
The tempo plot has been introduced by @dye2016. See @philippe2020 for more statistical details.

The tempo plot is one way to measure change over time: it estimates the cumulative occurrence of archaeological events in a Bayesian calibration. The tempo plot yields a graphic where the slope of the plot directly reflects the pace of change: a period of rapid change yields a steep slope and a period of slow change yields a gentle slope. When there is no change, the plot is horizontal. When change is instantaneous, the plot is vertical.

```{r tempo-plot, fig.height=5}
## Warning: this may take a few seconds
tp <- tempo(chrono_events, level = 0.95, count = FALSE)
plot(tp)
```

From these graphs, we can see that the highest part of the sampled activity is dated between -45 000 to -35 000 but two dates are younger, at about -32 000 and -28 000.

### Activity Plot
The activity plot displays the derivative of the Bayes estimate of the Tempo plot. It is an other way to see changes over time.

```{r activity-plot, fig.height=5}
## Warning: this may take a few seconds
ac <- activity(tp)
plot(ac)
```

### Occurrence Plot
The Occurrence plot calculates the calendar date $t$ corresponding to the smallest date such that the number of events observed before $t$ is equal to $k$, for $k = [(1, 16)]$. The Occurrence plot draws the credible intervals or the highest posterior density (HPD) region of those dates associated to a desired level of confidence.

```{r occurrence-plot, fig.height=5}
## Warning: this may take a few seconds
oc <- occurrence(chrono_events, level = 0.95)
plot(oc)
```

## Analysis of groups of dates
### Groups of dates

A group of dates (phase) is defined by the date of the minimum and the date of the maximum of the group. In this part, we will use the data containing these values for each group of dates.

```{r}
## Build phases from events
p <- list(EPI = 1, UP = 2:4, Ahmarian = 5:15, IUP = 16)
chrono_groups <- phase(chrono_events, groups = p)

all(chrono_groups == chrono_phases)
```

We can estimate the time range of a group of dates as the shortest interval that contains all the dates of the group at a given confidence level [@philippe2020].

The following code gives the endpoints of the time range of all groups of dates of Ksar Akil data at a given confidence level.

```{r}
boundaries(chrono_groups, level = 0.95)
```

The time range interval of the group of dates is a way to summarize the estimation of its minimum, the estimation of its maximum and their uncertainties at the same time.

```{r, fig.height=5}
plot(chrono_groups, level = 0.95)
```

### Succession of groups

We may also be interested in a succession of phases. This is actually the case of the succession of *IUP*, *Ahmarian*, *UP* and *EPI* that are in stratigraphic order. Hence, we can estimate the transition interval and, if it exists, the gap between these successive phases.

```{r}
set_order(chrono_groups) <- c("IUP", "Ahmarian", "UP", "EPI")
get_order(chrono_groups)
```

#### Transistions between successive groups

The transition interval between two successive phases is the shortest interval that covers the end of the oldest group of dates and the start of the youngest group of dates. The start and the end are estimated by the minimum and the maximum of the dates included in the group of dates. It gives an idea of the transition period between two successive group of dates. From a computational point of view this is equivalent to the time range calculated between the end of the oldest group of dates and the start of the youngest group of dates.

```{r}
transition(chrono_groups, level = 0.95)
```

#### Gap between successive groups

Successive phases may also be separated in time. Indeed there may exist a gap between them. This testing procedure check whether a gap exists between two successive groups of dates with fixed probability. If a gap exists, it is an interval that covers the end of one group of dates and the start of the successive one with fixed posterior probability.

```{r}
hiatus(chrono_groups, level = 0.95)
```

At a confidence level of 95%, there is no gap between the succession of phases *IUP*, *Ahmarian* and *UP*, but there exists one of 203 years between phase *UP* and phase *EPI*.

```{r, fig.height=2}
plot(chrono_groups, level = 0.95)
```

## References
